#!/bin/bash
#
# sbx - SlackBuilds.org package manager designed to provide a clean and straightforward command-line interface
# Copyright (C) 2025 Rogério Girão
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Project Page: https://github.com/rgcastrof/sbx
# Rogério Girão rogeriogirao1@proton.me
#

NAME=${NAME:-"sbx"}
REPO_DIR=${REPO_DIR:-"/var/lib/sbx/SBo"}
REPO_URL=${REPO_URL:-"git://git.slackbuilds.org/slackbuilds.git"}
DIST_DIR=${DIST_DIR:-"/var/cache/sbx"}
VERSION=${VERSION_DIR:-"1.1.0"}
TMP=${TMP:-"/tmp/build"}

# print error and exit
function perror()
{
	local fmt="$1"
	echo "$fmt" && exit 1
}

# Load package .info file
function load_pkg_info()
{
	local info_file="$1"
	if [ ! -f "$info_file" ]; then
		echo "Info file: $info_file not found"
		echo "Unable to download the distfiles"
	else
		# clean the environment and load info
		unset PRGNAM VERSION HOMEPAGE DOWNLOAD MD5SUM DOWNLOAD_x86_64 MD5SUM_x86_64 REQUIRES MAINTAINER EMAIL
		source "$info_file"
	fi
}

# If not exists clone SBo repository else update it
function sync_repo()
{
	if [ ! -d "$REPO_DIR/.git" ]; then
		echo "Cloning SlackBuilds.org repository."
		mkdir -p "$REPO_DIR"
		if ! git clone "$REPO_URL" "$REPO_DIR"; then
			perror "Failed to clone repository."
		fi
		echo "Clone completed."
	else
		echo "Updating SlackBuilds.org repository."
		if ! git --git-dir="$REPO_DIR/.git" --work-tree="$REPO_DIR" pull; then
			perror "Failed to update SlackBuilds.org repository."
		else
			echo "Update completed."
		fi
	fi
}

# Query the specified package
function query_pkg()
{
	for pkg in "$@"; do
		echo
		echo "Searching for $pkg..."
		local results=$(find "$REPO_DIR" -type d -name "*$pkg*" -maxdepth 2 | sed 's|.*/SBo/||')
		[ -z "$results" ] && perror "No match for $pkg found"

		echo "Found the following matches for $pkg:"
		echo "------------------------------"
		echo "$results"
		echo "------------------------------"
	done
}

# if one of the variables doesnt exists, get the other and vice versa
function get_urls()
{
	if [ -z "$DOWNLOAD_x86_64" ] || [ "$DOWNLOAD_x86_64" = "UNSUPPORTED" ]; then
		urls=($DOWNLOAD)
	else
		urls=($DOWNLOAD_x86_64)
	fi
}

# same here
function get_md5sums()
{
	if [ -z "$MD5SUM_x86_64" ] || [ "$MD5SUM_x86_64" = "UNSUPPORTED" ]; then
		md5sums=($MD5SUM)
	else
		md5sums=($MD5SUM_x86_64)
	fi
}

# Check if the distfile exists and do checksum
function checksum()
{
	local distfile=$(basename "$1")
	local idx="$2"
	local result=$(find "$DIST_DIR" -type f -name "$distfile")
	[ -f "$result" ] && hash=$(md5sum "$result" | awk '{print $1}') || perror "Distfile: $distfile not found"  # exit if a distfile is missing
	fmt="MD5SUM check for $distfile ..."
	[ "$hash" == "${md5sums[$idx]}" ] && echo "$fmt OK" || echo "$fmt FAILED"
}

# Download the distfiles
function fetch_distfiles()
{
	[ ! -d "$DIST_DIR" ] && mkdir -p "$DIST_DIR"
	for pkg in "$@"; do
		local result=$(find "$REPO_DIR" -type d -name "$pkg" -maxdepth 2)
		if [ -z "$result" ]; then
			echo "Package $pkg not found"
		else
			load_pkg_info "$result/$pkg.info"
			get_urls
			get_md5sums
			for ((i=0; i<${#urls[@]}; i++)); do
				url="${urls[$i]}"
				echo "--> Fetching: $url"
				wget -c -P "$DIST_DIR" "$url" || perror "ERROR: failed to fetch $url"
				checksum "$url" "$i"
			done
		fi
	done
}

function build_pkg()
{
	mkdir -p "$TMP"  # Create dir where the Slackbuild script will be executed
	case "$TMP" in
		/tmp/*) ;;
		*) perror "ERROR: invalid TMP directory: $TMP" ;;
	esac

	for pkg in "$@"; do
		fetch_distfiles "$pkg"
		for ((j=0; j<${#urls[@]}; j++)); do
			local distpath=$(find "$DIST_DIR" -type f -name "$(basename "${urls[$j]}")")
			if [ -f "$distpath" ]; then  # Check if the distfile exists
				# Copy the required files to the temp directory
				# and run the SlackBuild script
				local pkg_dir=$(find "$REPO_DIR" -type d -name "$pkg" -maxdepth 2)
				cp -r "$pkg_dir" "$TMP"
				cp "$distpath" "$TMP/$pkg"
				cd "$TMP/$pkg" && bash "$pkg.SlackBuild"
			else
				perror "distfile $distpath not found."  # Exit if a distfile is missing
			fi
		done
	done
	rm -rf -- "$TMP"  # Clean the temp directory after the build
}

function install_pkg()
{
	for pkg in "$@"; do
		build_pkg "$pkg"
		tgz=$(find /tmp/ -type f -name "$pkg*_SBo.tgz" -maxdepth 1 | sort | tail -n1)  # Gets the most recently compiled version
		if /sbin/upgradepkg --reinstall --install-new "$tgz"; then
			echo "Package installed/reinstalled successfully."
		else
			perror "ERROR: Failed to install/reinstall package."
		fi
	done
}

function update_pkgs()
{
	local sbos=($(find /var/log/packages/ -type f -printf "%f\n" | grep _SBo))  # Get installed packages
	echo "Searching for potential updates..."
	echo
	for ((i=0; i<${#sbos[@]}; i++)); do
		local pkgnam=$(echo "${sbos[$i]}" | sed 's/-[0-9].*$//')  # Get only the name
		local pkgver=$(echo "${sbos[$i]}" | sed 's|^.*-\([0-9][0-9._]*\)-.*|\1|')  # Get only the version
		local pkg_dir=$(find "$REPO_DIR" -type d -name "$pkgnam" -maxdepth 2)
		load_pkg_info "$pkg_dir/$pkgnam.info"

		# Check if the versions are different
		# and which one is more up to date
		if [ "$pkgver" != "$VERSION" ]; then
			if [ "$(printf '%s\n' "$pkgver" "$VERSION" | sort -V | tail -n1)" = "$VERSION" ]; then
				fmt="Installed version is outdated."
			else
				fmt="Installed version is newer than repo."
			fi
			# Show packages with potential updates
			cat <<EOF
$pkgnam:
  $fmt
  INSTALLED VERSION: $pkgver
  REPO VERSION: $VERSION

EOF
		fi
	done
	echo "Potential update list complete."
}

function print_help()
{
	cat <<EOF
$NAME $VERSION
Usage: $NAME [OPTIONS] <package(s)>
Available options:
  -s             Sync the remote repository with the local mirror.
  -u             Search for potential updates to installed packages.
  -f package(s)  Download the distfiles of the specified package(s).
  -b package(s)  Build the specified package(s).
  -i package(s)  Same of '-b', but also install built packages.
  -q package(s)  Search for packages matching string.
  -h             Display this help message.
  -v             Print $NAME version.
EOF
	exit 0
}

# Check if the script is being run as root
if [ "$(id -u)" -ne 0 ]; then
	perror "sbx can only be executed as root. Exiting."
fi

# If no args are passed
# print help and exit
[ $# -eq 0 ] && print_help

# command-line parsing
#
# Args variables
SYNC=0
UPDATE=0
FETCH=()
BUILD=()
INSTALL=()
QUERY=()
current=""

for arg in "$@"; do
	case "$arg" in  # Check if arg is a flag
		-*)
			flags="${arg:1}"
			for ((i=0; i < ${#flags}; i++)); do  # Loop through every flag
				flag="${flags:$i:1}"
				case "$flag" in
					s) SYNC=1; current="" ;;
					u) UPDATE=1 ;;
					f) current="FETCH" ;;
					b) current="BUILD" ;;
					q) current="QUERY" ;;
					i) current="INSTALL" ;;
					v) echo "$VERSION" && exit 0 ;;
					h) print_help ;;
					*) perror "ERROR: Unknown option: -$flag" ;;
				esac
			done
			;;
		*)  # If is not a flag, is a argument of the flag
			case "$current" in
				FETCH) FETCH+=("$arg") ;;
				BUILD) BUILD+=("$arg") ;;
				QUERY) QUERY+=("$arg") ;;
				INSTALL) INSTALL+=("$arg") ;;
			esac
			;;
	esac
done

[ "$SYNC" -eq 1 ] && sync_repo
[ "$UPDATE" -eq 1 ] && update_pkgs
[ "${#FETCH[@]}" -gt 0 ] && fetch_distfiles "${FETCH[@]}"
[ "${#QUERY[@]}" -gt 0 ] && query_pkg "${QUERY[@]}"
[ "${#BUILD[@]}" -gt 0 ] && build_pkg "${BUILD[@]}"
[ "${#INSTALL[@]}" -gt 0 ] && install_pkg "${INSTALL[@]}"

exit 0
