#!/bin/bash
#
# sbx - Build, install and update SlackBuilds.org packages
# Copyright (C) 2025 Rogério Girão
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Project Page: https://github.com/rgcastrof/sbx
# Rogério Girão rogeriogirao1@proton.me
#

NAME=${NAME:-"sbx"}
VERSION=${VERSION:-"1.2.2"}
REPO_DIR=${REPO_DIR:-"/var/lib/sbx/SBo"}
REPO_URL=${REPO_URL:-"git://git.slackbuilds.org/slackbuilds.git"}
DIST_DIR=${DIST_DIR:-"/var/cache/sbx"}
TMP=${TMP:-"/tmp/build"}

# print error and exit
function perror()
{
	local fmt="$1"
	echo "$fmt" && exit 1
}

# Load package .info file
function load_pkg_info()
{
	local info_file="$1"
	if [ ! -f "$info_file" ]; then
		perror "ERROR: Missing .info file: $info_file."
	else
		# clean the environment and load info
		unset PRGNAM VERSION HOMEPAGE DOWNLOAD MD5SUM DOWNLOAD_x86_64 MD5SUM_x86_64 REQUIRES MAINTAINER EMAIL
		set -a
		source "$info_file" || perror "ERROR: Failed to load $info_file."
		set +a
	fi
}

# If a local mirror doesnt exist, clone it
# Else, pull the changes
function sync_repo()
{
	if [ ! -d "$REPO_DIR/.git" ]; then
		echo "Cloning SlackBuilds.org repository."
		mkdir -p "$REPO_DIR"
		if ! git clone "$REPO_URL" "$REPO_DIR"; then
			perror "Failed to clone repository."
		fi
		echo "Clone completed."
	else
		echo "Updating SlackBuilds.org repository."
		if ! git --git-dir="$REPO_DIR/.git" --work-tree="$REPO_DIR" pull; then
			perror "Failed to update SlackBuilds.org repository."
		else
			echo "Update completed."
		fi
	fi
}

function simple_query() {
	local pkg="$1"
	local pkgpath="$2"

	echo "Found the following matches for $pkg:"
	echo "----------------------------------------"
	# Print relative SBo path and package version aligned
	printf '%-40s  %s\n' "$(echo "$pkgpath" | sed 's|.*/SBo/||')"  "$VERSION"
	echo "----------------------------------------"
}

function detailed_query() {
	local pkgpath="$1"
	local relpath="$(echo "$pkgpath" | sed 's|.*/SBo/||')"
	# cut the slack-desc header to show only
	# the package description
	local desc=$(awk '/handy-ruler/ {flag=1; next} flag' "$pkgpath/slack-desc")
	cat <<EOF
----------------------------------------
PACKAGE NAME: $PRGNAM
PACKAGE VERSION: $VERSION
PACKAGE LOCATION: $relpath
PACKAGE HOMEPAGE: $HOMEPAGE
PACKAGE MAINTAINER: $MAINTAINER <$EMAIL>
PACKAGE REQUIRES: $REQUIRES
PACKAGE DESCRIPTION:
$desc
----------------------------------------

EOF
}

# Dispatch query results to the appropriate output formatter
# Mode 0 = simple, Mode 1 = detailed
function run_query_results() {
	local mode="$1"
	shift

	for pkgpath in "$@"; do
		load_pkg_info "$pkgpath/$(basename "$pkgpath").info"
		[ "$mode" -eq 1 ] && detailed_query "$pkgpath" || simple_query "$PRGNAM" "$pkgpath"
	done
}

# Main query entry point
function query_pkg()
{
	local querymode="$1"
	shift
	local pattern
	local -a results

	for pkg in "$@"; do
		echo
		echo "Searching for $pkg..."
		# Exact match is used in detailed mode (-Q)
		# partial match is used in simple mode (-q)
		pattern=$([ "$querymode" -eq 1 ] && echo "$pkg" || echo "*$pkg*")
		mapfile -t results < <(find "$REPO_DIR" -mindepth 2 -maxdepth 2 -type d -name "$pattern")

		if [ "${#results[@]}" -eq 0 ]; then
			echo "No match for $pkg found"
			continue
		fi
		run_query_results "$querymode" "${results[@]}"
	done
}

# if one of the variables doesnt exists, get the other and vice versa
function get_urls()
{
	if [ -z "$DOWNLOAD_x86_64" ] || [ "$DOWNLOAD_x86_64" = "UNSUPPORTED" ]; then
		urls=($DOWNLOAD)
	else
		urls=($DOWNLOAD_x86_64)
	fi
}

# same here
function get_md5sums()
{
	if [ -z "$MD5SUM_x86_64" ] || [ "$MD5SUM_x86_64" = "UNSUPPORTED" ]; then
		md5sums=($MD5SUM)
	else
		md5sums=($MD5SUM_x86_64)
	fi
}

# Check if the distfile exists and do checksum
function checksum()
{
	local distfile=$(basename "$1")
	local idx="$2"
	local result=$(find "$DIST_DIR" -type f -name "$distfile")
	[ -f "$result" ] && hash=$(md5sum "$result" | awk '{print $1}') || perror "Distfile: $distfile not found"  # exit if a distfile is missing
	fmt="MD5SUM check for $distfile ..."
	[ "$hash" == "${md5sums[$idx]}" ] && echo "$fmt OK" || perror "$fmt FAILED"
}

# Download the distfiles
function fetch_distfiles()
{
	[ ! -d "$DIST_DIR" ] && mkdir -p "$DIST_DIR"
	for pkg in "$@"; do
		local result=$(find "$REPO_DIR" -maxdepth 2 -type d -name "$pkg")
		if [ -z "$result" ]; then
			echo "Package $pkg not found"
		else
			load_pkg_info "$result/$pkg.info"
			get_urls
			get_md5sums
			for ((i=0; i<${#urls[@]}; i++)); do
				url="${urls[$i]}"
				echo "==> Fetching: $url"
				wget -c -P "$DIST_DIR" "$url" || perror "ERROR: failed to fetch $url"
				checksum "$url" "$i"
			done
		fi
	done
}

function build_pkg()
{
	mkdir -p "$TMP"  # Create dir where the Slackbuild script will be executed
	case "$TMP" in
		/tmp/*) ;;
		*) perror "ERROR: invalid TMP directory: $TMP" ;;
	esac

	for pkg in "$@"; do
		unset urls md5sums
		fetch_distfiles "$pkg"
		echo "==> Building $pkg"
		local pkgpath=$(find "$REPO_DIR" -mindepth 2 -maxdepth 2 -type d -name "$pkg")
		cp -r "$pkgpath" "$TMP"
		for ((j=0; j<${#urls[@]}; j++)); do
			local distpath=$(find "$DIST_DIR" -type f -name "$(basename "${urls[$j]}")")
			if [ -f "$distpath" ]; then     # Check if the distfile exists
				cp "$distpath" "$TMP/$pkg"  # and copy it to the temp directory
			else
				perror "distfile $distpath not found."  # Exit if a distfile is missing
			fi
		done
		cd "$TMP/$pkg"
		#  Clean the temp directory if the build was successful
		if bash "$pkg.SlackBuild"; then
			rm -rf -- "$TMP/$pkg"
		fi
	done
}

function install_pkg()
{
	for pkg in "$@"; do
		tgz=$(find /tmp/ -maxdepth 1 -type f -name "$pkg*_SBo.tgz" | sort | tail -n1)  # Gets the most recently compiled version
		if /sbin/upgradepkg --reinstall --install-new "$tgz"; then
			echo "Package installed/reinstalled successfully."
		else
			perror "ERROR: Failed to install/reinstall package."
		fi
	done
}

function update_pkgs()
{
	local pkgnam pkgver pkgpath fmt
	local -a sbos
	mapfile -t sbos < <(find /var/log/packages/ -type f -printf "%f\n" | grep _SBo)  # Get installed packages
	echo "Searching for potential updates..."
	echo

	for ((i=0; i<${#sbos[@]}; i++)); do
		pkgnam=$(echo "${sbos[$i]}" | sed 's/-[0-9].*$//')  # Get only the name
		pkgver=$(echo "${sbos[$i]}" | sed 's|^.*-\([0-9][0-9._]*\)-.*|\1|')  # Get only the version
		pkgpath=$(find "$REPO_DIR" -mindepth 2 -maxdepth 2 -type d -name "$pkgnam")
		load_pkg_info "$pkgpath/$pkgnam.info"

		# Check if the versions are different
		# and which one is more up to date
		if [ "$pkgver" != "$VERSION" ]; then
			if [ "$(printf '%s\n' "$pkgver" "$VERSION" | sort -V | tail -n1)" = "$VERSION" ]; then
				fmt="Installed version is outdated."
			else
				fmt="Installed version is newer than repo."
			fi
			# Show packages with potential updates
			cat <<EOF
$pkgnam:
  $fmt
  INSTALLED VERSION: $pkgver
  REPO VERSION: $VERSION

EOF
		fi
	done
	echo "Potential update list complete."
}

function print_help()
{
	cat <<EOF
$NAME $VERSION
Usage: $NAME [OPTIONS] <package(s)>
Available options:
  -s             Sync the remote repository with the local mirror.
  -u             Search for potential updates to installed packages.
  -f package(s)  Download the distfiles of the specified package(s).
  -b package(s)  Build the specified package(s).
  -i package(s)  Install built packages.
  -q package(s)  Search for packages matching string.
  -Q package(s)  Query packages by exact name and display detailed information.
  -h             Display this help message.
  -v             Print $NAME version.
EOF
	exit 0
}

# Check if the script is being run as root
if [ "$(id -u)" -ne 0 ]; then
	perror "sbx can only be executed as root. Exiting."
fi

# If no args are passed
# print help and exit
[ $# -eq 0 ] && print_help

# command-line parsing
#
# Args variables
SYNC=0
UPDATE=0
QUERYMODE=0
FETCH=()
BUILD=()
INSTALL=()
QUERY=()
current=""

for arg in "$@"; do
	case "$arg" in  # Check if arg is a flag
		-*)
			flags="${arg:1}"
			for ((i=0; i < ${#flags}; i++)); do  # Loop through every flag
				flag="${flags:$i:1}"
				case "$flag" in
					s) SYNC=1; current="" ;;
					u) UPDATE=1 ;;
					f) current="FETCH" ;;
					b) current="BUILD" ;;
					q|Q)
						[ "$flag" = "Q" ] && QUERYMODE=1 || QUERYMODE=0
						current="QUERY"
						;;
					i) current="INSTALL" ;;
					v) echo "$VERSION" && exit 0 ;;
					h) print_help ;;
					*) perror "ERROR: Unknown option: -$flag" ;;
				esac
			done
			;;
		*)  # If is not a flag, is a argument of the flag
			case "$current" in
				FETCH) FETCH+=("$arg") ;;
				BUILD) BUILD+=("$arg") ;;
				QUERY) QUERY+=("$arg") ;;
				INSTALL) INSTALL+=("$arg") ;;
			esac
			;;
	esac
done

[ "$SYNC" -eq 1 ] && sync_repo
[ "$UPDATE" -eq 1 ] && update_pkgs
[ "${#FETCH[@]}" -gt 0 ] && fetch_distfiles "${FETCH[@]}"
[ "${#QUERY[@]}" -gt 0 ] && query_pkg "$QUERYMODE" "${QUERY[@]}"
[ "${#BUILD[@]}" -gt 0 ] && build_pkg "${BUILD[@]}"
[ "${#INSTALL[@]}" -gt 0 ] && install_pkg "${INSTALL[@]}"

exit 0
